name: Cleanup Orphaned Preview Resources

# Runs daily to clean up any preview resources from closed PRs
# that weren't properly cleaned up (e.g., if cleanup workflow failed)

on:
  schedule:
    # Run daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch: # Allow manual trigger

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: northamerica-northeast2

jobs:
  cleanup-orphaned:
    name: Find and Cleanup Orphaned Previews
    runs-on: ubuntu-latest

    permissions:
      contents: read
      id-token: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Find orphaned preview services
        id: find-orphans
        uses: actions/github-script@v7
        with:
          script: |
            // Get all open PRs
            const { data: openPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const openPRNumbers = new Set(openPRs.map(pr => pr.number));
            console.log(`Open PRs: ${Array.from(openPRNumbers).join(', ') || 'none'}`);

            // Return as JSON for bash to parse
            core.setOutput('open_prs', JSON.stringify(Array.from(openPRNumbers)));

      - name: Cleanup orphaned Cloud Run services
        run: |
          echo "Finding orphaned preview services..."

          # Get all preview services
          PREVIEW_SERVICES=$(gcloud run services list \
            --region=${{ env.GCP_REGION }} \
            --project=${{ env.GCP_PROJECT_ID }} \
            --filter="metadata.name~ishkul-backend-pr-" \
            --format="value(metadata.name)" 2>/dev/null || echo "")

          if [ -z "$PREVIEW_SERVICES" ]; then
            echo "No preview services found"
            exit 0
          fi

          # Parse open PR numbers from previous step
          OPEN_PRS='${{ steps.find-orphans.outputs.open_prs }}'
          echo "Open PRs: $OPEN_PRS"

          ORPHANED_COUNT=0
          DELETED_SERVICES=""

          for SERVICE in $PREVIEW_SERVICES; do
            # Extract PR number from service name (ishkul-backend-pr-123 -> 123)
            PR_NUM=$(echo "$SERVICE" | sed 's/ishkul-backend-pr-//')

            # Check if this PR is still open
            if echo "$OPEN_PRS" | grep -q "\"$PR_NUM\"" || echo "$OPEN_PRS" | grep -q ",$PR_NUM," || echo "$OPEN_PRS" | grep -q "\[$PR_NUM," || echo "$OPEN_PRS" | grep -q ",$PR_NUM\]"; then
              echo "PR #$PR_NUM is still open, keeping $SERVICE"
            else
              echo "PR #$PR_NUM is closed, deleting orphaned service: $SERVICE"

              if gcloud run services delete "$SERVICE" \
                --region=${{ env.GCP_REGION }} \
                --project=${{ env.GCP_PROJECT_ID }} \
                --quiet; then
                ORPHANED_COUNT=$((ORPHANED_COUNT + 1))
                DELETED_SERVICES="$DELETED_SERVICES $SERVICE"
              else
                echo "Failed to delete $SERVICE"
              fi
            fi
          done

          echo "orphaned_count=$ORPHANED_COUNT" >> $GITHUB_OUTPUT
          echo "deleted_services=$DELETED_SERVICES" >> $GITHUB_OUTPUT

          if [ $ORPHANED_COUNT -gt 0 ]; then
            echo "Cleaned up $ORPHANED_COUNT orphaned services"
          else
            echo "No orphaned services found"
          fi

      - name: Setup Go for Firestore cleanup
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Cleanup orphaned Firestore data
        run: |
          # Get open PR numbers
          OPEN_PRS='${{ steps.find-orphans.outputs.open_prs }}'

          # Create cleanup script
          cat > /tmp/cleanup_orphans.go << 'CLEANUP_EOF'
          package main

          import (
            "context"
            "encoding/json"
            "fmt"
            "log"
            "os"
            "strings"

            "cloud.google.com/go/firestore"
            "google.golang.org/api/iterator"
          )

          func main() {
            ctx := context.Background()
            projectID := os.Getenv("GCP_PROJECT_ID")
            openPRsJSON := os.Getenv("OPEN_PRS")

            if projectID == "" {
              log.Fatal("GCP_PROJECT_ID must be set")
            }

            // Parse open PRs
            var openPRs []int
            if err := json.Unmarshal([]byte(openPRsJSON), &openPRs); err != nil {
              log.Printf("Warning: Could not parse open PRs: %v", err)
            }

            openPRSet := make(map[int]bool)
            for _, pr := range openPRs {
              openPRSet[pr] = true
            }

            client, err := firestore.NewClient(ctx, projectID)
            if err != nil {
              log.Fatalf("Failed to create Firestore client: %v", err)
            }
            defer client.Close()

            // Find all collections with pr_X_ prefix
            collections := []string{"users", "learning_paths"}
            cleanedCount := 0

            for _, baseCol := range collections {
              // We need to check for orphaned prefixed collections
              // Firestore doesn't have a way to list all collections matching a pattern,
              // so we'll iterate through possible PR numbers (1-9999)
              for prNum := 1; prNum <= 9999; prNum++ {
                if openPRSet[prNum] {
                  continue // Skip open PRs
                }

                prefix := fmt.Sprintf("pr_%d_", prNum)
                colName := prefix + baseCol

                // Check if collection has any documents
                iter := client.Collection(colName).Limit(1).Documents(ctx)
                doc, err := iter.Next()
                iter.Stop()

                if err == iterator.Done || doc == nil {
                  continue // Collection doesn't exist or is empty
                }
                if err != nil && !strings.Contains(err.Error(), "not found") {
                  continue
                }

                // Collection exists and PR is closed - clean it up
                fmt.Printf("Found orphaned collection: %s (PR #%d is closed)\n", colName, prNum)

                // Delete all documents
                deleteIter := client.Collection(colName).Documents(ctx)
                batch := client.Batch()
                batchSize := 0
                docCount := 0

                for {
                  doc, err := deleteIter.Next()
                  if err == iterator.Done {
                    break
                  }
                  if err != nil {
                    log.Printf("Error iterating %s: %v", colName, err)
                    break
                  }

                  batch.Delete(doc.Ref)
                  batchSize++
                  docCount++

                  if batchSize >= 500 {
                    if _, err := batch.Commit(ctx); err != nil {
                      log.Printf("Error committing batch: %v", err)
                    }
                    batch = client.Batch()
                    batchSize = 0
                  }
                }

                if batchSize > 0 {
                  if _, err := batch.Commit(ctx); err != nil {
                    log.Printf("Error committing final batch: %v", err)
                  }
                }

                fmt.Printf("Deleted %d documents from %s\n", docCount, colName)
                cleanedCount++
              }
            }

            fmt.Printf("\nTotal orphaned collections cleaned: %d\n", cleanedCount)
          }
          CLEANUP_EOF

          cd /tmp
          go mod init cleanup
          go get cloud.google.com/go/firestore
          go get google.golang.org/api/iterator

          OPEN_PRS="$OPEN_PRS" \
          GCP_PROJECT_ID="${{ env.GCP_PROJECT_ID }}" \
          go run cleanup_orphans.go || echo "Firestore cleanup completed (some errors may be expected)"

      - name: Cleanup orphaned Docker images
        run: |
          echo "Finding orphaned Docker images..."

          REGISTRY="${{ env.GCP_REGION }}-docker.pkg.dev"
          REPO="${REGISTRY}/${{ env.GCP_PROJECT_ID }}/cloud-run-source-deploy/ishkul-backend"

          OPEN_PRS='${{ steps.find-orphans.outputs.open_prs }}'

          # Get all PR-tagged images
          TAGS=$(gcloud artifacts docker tags list ${REPO} \
            --filter="tag~pr-" \
            --format="value(tag)" 2>/dev/null || echo "")

          if [ -z "$TAGS" ]; then
            echo "No preview images found"
            exit 0
          fi

          DELETED_COUNT=0

          for TAG in $TAGS; do
            # Extract PR number from tag (pr-123-abc123 -> 123)
            PR_NUM=$(echo "$TAG" | sed 's/pr-//' | cut -d'-' -f1)

            # Check if this PR is still open
            if echo "$OPEN_PRS" | grep -qE "[\[,]${PR_NUM}[,\]]"; then
              echo "PR #$PR_NUM is still open, keeping image: $TAG"
            else
              echo "PR #$PR_NUM is closed, deleting orphaned image: $TAG"
              if gcloud artifacts docker images delete "${REPO}:${TAG}" --quiet 2>/dev/null; then
                DELETED_COUNT=$((DELETED_COUNT + 1))
              fi
            fi
          done

          echo "Deleted $DELETED_COUNT orphaned images"

      - name: Summary
        run: |
          echo "## Orphaned Preview Cleanup Summary ðŸ§¹" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This job runs daily to clean up preview resources from closed PRs" >> $GITHUB_STEP_SUMMARY
          echo "that weren't properly cleaned up by the normal cleanup workflow." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Actions Taken" >> $GITHUB_STEP_SUMMARY
          echo "- Checked for orphaned Cloud Run services" >> $GITHUB_STEP_SUMMARY
          echo "- Checked for orphaned Firestore data" >> $GITHUB_STEP_SUMMARY
          echo "- Checked for orphaned Docker images" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Cleanup completed!" >> $GITHUB_STEP_SUMMARY
